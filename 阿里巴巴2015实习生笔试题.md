# 循环队列

    队列(Queue)也是一种运算受限的线性表。它只允许在表的一端进行插入，而在另一端进行删除。
    循环队列是将顺序队列首尾相连形成的，随着插入元素或删除元素的进行，其队头指针及队尾指针是在不断变化的，有时可能会出现队头指针大于队尾指针的情况，也可能是队尾指针大于队头指针。
    循环队列元素个数：n=(rear-front+MAXSIZE)mod MAXSIZE 其中rear表示队尾，front表示队首，MAXSIZE表示队列长度
    
# 指令集

    常用的精简指令集 RISC 微处理器包括 DECAlpha 、 ARC 、 ARM 、 AVR 、 MIPS 、 PA-RISC 、 PowerArchitecture( 包括 PowerPC) 和 SPARC 等。 
    复杂指令 CISC如X86

# 二进制操作
    十进制数据右移n位，乘以10^n,左移n位，除以10^n
    二进制数据右移n位，乘以2^n,左移n位，除以2^n(右移数据变大，乘操作，左移数据变小，除操作)

# IP数据报头采用big_endian字节序，在此字节序下从低地址到高地址0x1234的表示形式为0 0 0x12 0x34（big高位在前） 。

# 分布式系统读写(IO)性能

    能改进分布式系统读写(IO)性能
        网络从千兆网升级为万兆网
        优化调度系统，尽量做到任务与数据相近（Locality）
        数据预取机制

    不可能改进分布式系统读写(IO)性能的是实现异步读写机制（异步IO就是调用系统IO来完成实际的IO操作）
        异步I/O不但不能提高i/O性能，有时反而有损I/O性能，因为Linux内核级别异步I/O不支持缓存操作，每次都必须从硬盘读取数据。与同步非阻塞I/O相比的优点在于：将异步I/O提交到内核后，内核会通知I/O设备独立的执行操作，这样服务进程可以继续充分占有CPU，而且，当大量读操作堆积到I/O设备的队列中，将会发挥内核的“电梯算法”优势，从而降低读磁盘成本。所以一般在读取文件时才使用异步I/O。

  # 排序算法
    排序方法        平均情况          最好情况          最坏情况         辅助空间              稳定性
    冒泡排序        O(n^2)           O(n)              O(n^2)            O(1)                稳定
    选择排序        O(n^2)           O(n^2)            O(n^2)            O(1)              不稳定
    插入排序        O(n^2)           O(n)              O(n^2)            O(1)                稳定
    希尔排序        O(n*log(n))~O(n^2) O(n^1.3)        O(n^2)            O(1)              不稳定
    堆排序          O(n*log(n))      O(n*log(n))       O(n*log(n))       O(1)              不稳定
    归并排序        O(n*log(n))      O(n*log(n))       O(n*log(n))       O(n)                稳定
    快速排序        O(n*log(n))      O(n*log(n))       O(n^2)            O(1)              不稳定
    
    
  # 树的度
  
    有公式：N2=N0-1，度为2的节点个数是度为0的节点个数减一，所以N0=3，则N2=2，再加上N1=8，总的是13    
    
# 创建进程所

    1,申请空白PCB（进程控制块）；
    2,为新进程分派资源；
    3,初始化PCB；
    4,将新进程插入就绪队列；           

    
